// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protos/services.proto

/*
Package protos is a generated protocol buffer package.

It is generated from these files:
	protos/services.proto

It has these top-level messages:
	Credentials
	RefreshToken
	SignedToken
	Message
	MessageStatus
	Comment
	FeedContent
	Profile
	GetNext
	Follow
	Like
	Tag
	Notification
	Picture
	Video
	Identifiers
	User
	Groupchat
	GeneralStatus
	Info
	File
	StreamedFileChunk
*/
package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MessageStatus_StatusCode int32

const (
	MessageStatus_SENT      MessageStatus_StatusCode = 0
	MessageStatus_DELIVERED MessageStatus_StatusCode = 1
	MessageStatus_READ      MessageStatus_StatusCode = 2
	MessageStatus_FAILED    MessageStatus_StatusCode = 3
)

var MessageStatus_StatusCode_name = map[int32]string{
	0: "SENT",
	1: "DELIVERED",
	2: "READ",
	3: "FAILED",
}
var MessageStatus_StatusCode_value = map[string]int32{
	"SENT":      0,
	"DELIVERED": 1,
	"READ":      2,
	"FAILED":    3,
}

func (x MessageStatus_StatusCode) String() string {
	return proto.EnumName(MessageStatus_StatusCode_name, int32(x))
}
func (MessageStatus_StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type GeneralStatus_StatusCode int32

const (
	GeneralStatus_OK                GeneralStatus_StatusCode = 0
	GeneralStatus_FAILED            GeneralStatus_StatusCode = 1
	GeneralStatus_UNKNOWN           GeneralStatus_StatusCode = 2
	GeneralStatus_PERMISSION_DENIED GeneralStatus_StatusCode = 3
	GeneralStatus_UNAUTHENTICATED   GeneralStatus_StatusCode = 4
	GeneralStatus_UNIMPLEMENTED     GeneralStatus_StatusCode = 5
	GeneralStatus_INTERNAL          GeneralStatus_StatusCode = 6
	GeneralStatus_CANCELLED         GeneralStatus_StatusCode = 7
)

var GeneralStatus_StatusCode_name = map[int32]string{
	0: "OK",
	1: "FAILED",
	2: "UNKNOWN",
	3: "PERMISSION_DENIED",
	4: "UNAUTHENTICATED",
	5: "UNIMPLEMENTED",
	6: "INTERNAL",
	7: "CANCELLED",
}
var GeneralStatus_StatusCode_value = map[string]int32{
	"OK":                0,
	"FAILED":            1,
	"UNKNOWN":           2,
	"PERMISSION_DENIED": 3,
	"UNAUTHENTICATED":   4,
	"UNIMPLEMENTED":     5,
	"INTERNAL":          6,
	"CANCELLED":         7,
}

func (x GeneralStatus_StatusCode) String() string {
	return proto.EnumName(GeneralStatus_StatusCode_name, int32(x))
}
func (GeneralStatus_StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{18, 0} }

type Credentials struct {
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *Credentials) Reset()                    { *m = Credentials{} }
func (m *Credentials) String() string            { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()               {}
func (*Credentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Credentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Credentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type RefreshToken struct {
}

func (m *RefreshToken) Reset()                    { *m = RefreshToken{} }
func (m *RefreshToken) String() string            { return proto.CompactTextString(m) }
func (*RefreshToken) ProtoMessage()               {}
func (*RefreshToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type SignedToken struct {
	Header    map[string]string `protobuf:"bytes,1,rep,name=header" json:"header,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Payload   map[string]string `protobuf:"bytes,2,rep,name=payload" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Signature string            `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
}

func (m *SignedToken) Reset()                    { *m = SignedToken{} }
func (m *SignedToken) String() string            { return proto.CompactTextString(m) }
func (*SignedToken) ProtoMessage()               {}
func (*SignedToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SignedToken) GetHeader() map[string]string {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SignedToken) GetPayload() map[string]string {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *SignedToken) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type Message struct {
	Text string `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	// Types that are valid to be assigned to Course:
	//	*Message_Username
	//	*Message_Groupchat
	Course         isMessage_Course `protobuf_oneof:"course"`
	Status         *MessageStatus   `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
	Identification int64            `protobuf:"varint,6,opt,name=identification" json:"identification,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isMessage_Course interface{ isMessage_Course() }

type Message_Username struct {
	Username *User `protobuf:"bytes,2,opt,name=username,oneof"`
}
type Message_Groupchat struct {
	Groupchat *Groupchat `protobuf:"bytes,3,opt,name=groupchat,oneof"`
}

func (*Message_Username) isMessage_Course()  {}
func (*Message_Groupchat) isMessage_Course() {}

func (m *Message) GetCourse() isMessage_Course {
	if m != nil {
		return m.Course
	}
	return nil
}

func (m *Message) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Message) GetUsername() *User {
	if x, ok := m.GetCourse().(*Message_Username); ok {
		return x.Username
	}
	return nil
}

func (m *Message) GetGroupchat() *Groupchat {
	if x, ok := m.GetCourse().(*Message_Groupchat); ok {
		return x.Groupchat
	}
	return nil
}

func (m *Message) GetStatus() *MessageStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Message) GetIdentification() int64 {
	if m != nil {
		return m.Identification
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_Username)(nil),
		(*Message_Groupchat)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// course
	switch x := m.Course.(type) {
	case *Message_Username:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Username); err != nil {
			return err
		}
	case *Message_Groupchat:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Groupchat); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Course has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 2: // course.username
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(User)
		err := b.DecodeMessage(msg)
		m.Course = &Message_Username{msg}
		return true, err
	case 3: // course.groupchat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Groupchat)
		err := b.DecodeMessage(msg)
		m.Course = &Message_Groupchat{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// course
	switch x := m.Course.(type) {
	case *Message_Username:
		s := proto.Size(x.Username)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Groupchat:
		s := proto.Size(x.Groupchat)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type MessageStatus struct {
}

func (m *MessageStatus) Reset()                    { *m = MessageStatus{} }
func (m *MessageStatus) String() string            { return proto.CompactTextString(m) }
func (*MessageStatus) ProtoMessage()               {}
func (*MessageStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type Comment struct {
	Text           string       `protobuf:"bytes,1,opt,name=text" json:"text,omitempty"`
	Identification int64        `protobuf:"varint,2,opt,name=identification" json:"identification,omitempty"`
	User           *User        `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	Picture        *FeedContent `protobuf:"bytes,4,opt,name=picture" json:"picture,omitempty"`
}

func (m *Comment) Reset()                    { *m = Comment{} }
func (m *Comment) String() string            { return proto.CompactTextString(m) }
func (*Comment) ProtoMessage()               {}
func (*Comment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Comment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Comment) GetIdentification() int64 {
	if m != nil {
		return m.Identification
	}
	return 0
}

func (m *Comment) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Comment) GetPicture() *FeedContent {
	if m != nil {
		return m.Picture
	}
	return nil
}

// *
// FeedContent represents the different types of content that can be displayed on a user's feed
type FeedContent struct {
	// Types that are valid to be assigned to Content:
	//	*FeedContent_Picture
	//	*FeedContent_Video
	Content isFeedContent_Content `protobuf_oneof:"content"`
}

func (m *FeedContent) Reset()                    { *m = FeedContent{} }
func (m *FeedContent) String() string            { return proto.CompactTextString(m) }
func (*FeedContent) ProtoMessage()               {}
func (*FeedContent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isFeedContent_Content interface{ isFeedContent_Content() }

type FeedContent_Picture struct {
	Picture *Picture `protobuf:"bytes,1,opt,name=picture,oneof"`
}
type FeedContent_Video struct {
	Video *Video `protobuf:"bytes,2,opt,name=video,oneof"`
}

func (*FeedContent_Picture) isFeedContent_Content() {}
func (*FeedContent_Video) isFeedContent_Content()   {}

func (m *FeedContent) GetContent() isFeedContent_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *FeedContent) GetPicture() *Picture {
	if x, ok := m.GetContent().(*FeedContent_Picture); ok {
		return x.Picture
	}
	return nil
}

func (m *FeedContent) GetVideo() *Video {
	if x, ok := m.GetContent().(*FeedContent_Video); ok {
		return x.Video
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FeedContent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FeedContent_OneofMarshaler, _FeedContent_OneofUnmarshaler, _FeedContent_OneofSizer, []interface{}{
		(*FeedContent_Picture)(nil),
		(*FeedContent_Video)(nil),
	}
}

func _FeedContent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FeedContent)
	// content
	switch x := m.Content.(type) {
	case *FeedContent_Picture:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Picture); err != nil {
			return err
		}
	case *FeedContent_Video:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Video); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FeedContent.Content has unexpected type %T", x)
	}
	return nil
}

func _FeedContent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FeedContent)
	switch tag {
	case 1: // content.picture
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Picture)
		err := b.DecodeMessage(msg)
		m.Content = &FeedContent_Picture{msg}
		return true, err
	case 2: // content.video
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Video)
		err := b.DecodeMessage(msg)
		m.Content = &FeedContent_Video{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FeedContent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FeedContent)
	// content
	switch x := m.Content.(type) {
	case *FeedContent_Picture:
		s := proto.Size(x.Picture)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeedContent_Video:
		s := proto.Size(x.Video)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Profile represents the data held on a user's profile
type Profile struct {
	User           *User          `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	ProfilePicture *Picture       `protobuf:"bytes,2,opt,name=profilePicture" json:"profilePicture,omitempty"`
	Content        []*FeedContent `protobuf:"bytes,3,rep,name=content" json:"content,omitempty"`
	Bio            string         `protobuf:"bytes,4,opt,name=bio" json:"bio,omitempty"`
}

func (m *Profile) Reset()                    { *m = Profile{} }
func (m *Profile) String() string            { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()               {}
func (*Profile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Profile) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Profile) GetProfilePicture() *Picture {
	if m != nil {
		return m.ProfilePicture
	}
	return nil
}

func (m *Profile) GetContent() []*FeedContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Profile) GetBio() string {
	if m != nil {
		return m.Bio
	}
	return ""
}

// *
// Used as a signal in bi-directional streaming to indicate the server sending the next element
type GetNext struct {
}

func (m *GetNext) Reset()                    { *m = GetNext{} }
func (m *GetNext) String() string            { return proto.CompactTextString(m) }
func (*GetNext) ProtoMessage()               {}
func (*GetNext) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// *
// Represents a follow from one user to another
type Follow struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
}

func (m *Follow) Reset()                    { *m = Follow{} }
func (m *Follow) String() string            { return proto.CompactTextString(m) }
func (*Follow) ProtoMessage()               {}
func (*Follow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Follow) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

// *
// Represents a like directed at a picture or comment
type Like struct {
	// Types that are valid to be assigned to LikedContent:
	//	*Like_Picture
	//	*Like_Comment
	LikedContent isLike_LikedContent `protobuf_oneof:"likedContent"`
}

func (m *Like) Reset()                    { *m = Like{} }
func (m *Like) String() string            { return proto.CompactTextString(m) }
func (*Like) ProtoMessage()               {}
func (*Like) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isLike_LikedContent interface{ isLike_LikedContent() }

type Like_Picture struct {
	Picture *Picture `protobuf:"bytes,1,opt,name=picture,oneof"`
}
type Like_Comment struct {
	Comment *Comment `protobuf:"bytes,2,opt,name=comment,oneof"`
}

func (*Like_Picture) isLike_LikedContent() {}
func (*Like_Comment) isLike_LikedContent() {}

func (m *Like) GetLikedContent() isLike_LikedContent {
	if m != nil {
		return m.LikedContent
	}
	return nil
}

func (m *Like) GetPicture() *Picture {
	if x, ok := m.GetLikedContent().(*Like_Picture); ok {
		return x.Picture
	}
	return nil
}

func (m *Like) GetComment() *Comment {
	if x, ok := m.GetLikedContent().(*Like_Comment); ok {
		return x.Comment
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Like) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Like_OneofMarshaler, _Like_OneofUnmarshaler, _Like_OneofSizer, []interface{}{
		(*Like_Picture)(nil),
		(*Like_Comment)(nil),
	}
}

func _Like_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Like)
	// likedContent
	switch x := m.LikedContent.(type) {
	case *Like_Picture:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Picture); err != nil {
			return err
		}
	case *Like_Comment:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Comment); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Like.LikedContent has unexpected type %T", x)
	}
	return nil
}

func _Like_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Like)
	switch tag {
	case 1: // likedContent.picture
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Picture)
		err := b.DecodeMessage(msg)
		m.LikedContent = &Like_Picture{msg}
		return true, err
	case 2: // likedContent.comment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Comment)
		err := b.DecodeMessage(msg)
		m.LikedContent = &Like_Comment{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Like_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Like)
	// likedContent
	switch x := m.LikedContent.(type) {
	case *Like_Picture:
		s := proto.Size(x.Picture)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Like_Comment:
		s := proto.Size(x.Comment)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Represents a tag done by a user to a separate user
type Tag struct {
	// Types that are valid to be assigned to TagLocation:
	//	*Tag_Picture
	//	*Tag_Comment
	TagLocation isTag_TagLocation `protobuf_oneof:"TagLocation"`
	User        *User             `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isTag_TagLocation interface{ isTag_TagLocation() }

type Tag_Picture struct {
	Picture *Picture `protobuf:"bytes,1,opt,name=picture,oneof"`
}
type Tag_Comment struct {
	Comment *Comment `protobuf:"bytes,2,opt,name=comment,oneof"`
}

func (*Tag_Picture) isTag_TagLocation() {}
func (*Tag_Comment) isTag_TagLocation() {}

func (m *Tag) GetTagLocation() isTag_TagLocation {
	if m != nil {
		return m.TagLocation
	}
	return nil
}

func (m *Tag) GetPicture() *Picture {
	if x, ok := m.GetTagLocation().(*Tag_Picture); ok {
		return x.Picture
	}
	return nil
}

func (m *Tag) GetComment() *Comment {
	if x, ok := m.GetTagLocation().(*Tag_Comment); ok {
		return x.Comment
	}
	return nil
}

func (m *Tag) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Tag) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Tag_OneofMarshaler, _Tag_OneofUnmarshaler, _Tag_OneofSizer, []interface{}{
		(*Tag_Picture)(nil),
		(*Tag_Comment)(nil),
	}
}

func _Tag_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Tag)
	// TagLocation
	switch x := m.TagLocation.(type) {
	case *Tag_Picture:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Picture); err != nil {
			return err
		}
	case *Tag_Comment:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Comment); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Tag.TagLocation has unexpected type %T", x)
	}
	return nil
}

func _Tag_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Tag)
	switch tag {
	case 1: // TagLocation.picture
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Picture)
		err := b.DecodeMessage(msg)
		m.TagLocation = &Tag_Picture{msg}
		return true, err
	case 2: // TagLocation.comment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Comment)
		err := b.DecodeMessage(msg)
		m.TagLocation = &Tag_Comment{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Tag_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Tag)
	// TagLocation
	switch x := m.TagLocation.(type) {
	case *Tag_Picture:
		s := proto.Size(x.Picture)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Tag_Comment:
		s := proto.Size(x.Comment)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Notification represents the kind of notifications given to users
type Notification struct {
	// Types that are valid to be assigned to Type:
	//	*Notification_Like
	//	*Notification_Message
	//	*Notification_Tag
	//	*Notification_Comment
	//	*Notification_Custom
	Type isNotification_Type `protobuf_oneof:"type"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type isNotification_Type interface{ isNotification_Type() }

type Notification_Like struct {
	Like *Like `protobuf:"bytes,1,opt,name=like,oneof"`
}
type Notification_Message struct {
	Message *Message `protobuf:"bytes,2,opt,name=message,oneof"`
}
type Notification_Tag struct {
	Tag *Tag `protobuf:"bytes,3,opt,name=tag,oneof"`
}
type Notification_Comment struct {
	Comment *Comment `protobuf:"bytes,4,opt,name=comment,oneof"`
}
type Notification_Custom struct {
	Custom string `protobuf:"bytes,5,opt,name=custom,oneof"`
}

func (*Notification_Like) isNotification_Type()    {}
func (*Notification_Message) isNotification_Type() {}
func (*Notification_Tag) isNotification_Type()     {}
func (*Notification_Comment) isNotification_Type() {}
func (*Notification_Custom) isNotification_Type()  {}

func (m *Notification) GetType() isNotification_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Notification) GetLike() *Like {
	if x, ok := m.GetType().(*Notification_Like); ok {
		return x.Like
	}
	return nil
}

func (m *Notification) GetMessage() *Message {
	if x, ok := m.GetType().(*Notification_Message); ok {
		return x.Message
	}
	return nil
}

func (m *Notification) GetTag() *Tag {
	if x, ok := m.GetType().(*Notification_Tag); ok {
		return x.Tag
	}
	return nil
}

func (m *Notification) GetComment() *Comment {
	if x, ok := m.GetType().(*Notification_Comment); ok {
		return x.Comment
	}
	return nil
}

func (m *Notification) GetCustom() string {
	if x, ok := m.GetType().(*Notification_Custom); ok {
		return x.Custom
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Notification) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Notification_OneofMarshaler, _Notification_OneofUnmarshaler, _Notification_OneofSizer, []interface{}{
		(*Notification_Like)(nil),
		(*Notification_Message)(nil),
		(*Notification_Tag)(nil),
		(*Notification_Comment)(nil),
		(*Notification_Custom)(nil),
	}
}

func _Notification_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Notification)
	// type
	switch x := m.Type.(type) {
	case *Notification_Like:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Like); err != nil {
			return err
		}
	case *Notification_Message:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Message); err != nil {
			return err
		}
	case *Notification_Tag:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Tag); err != nil {
			return err
		}
	case *Notification_Comment:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Comment); err != nil {
			return err
		}
	case *Notification_Custom:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Custom)
	case nil:
	default:
		return fmt.Errorf("Notification.Type has unexpected type %T", x)
	}
	return nil
}

func _Notification_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Notification)
	switch tag {
	case 1: // type.like
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Like)
		err := b.DecodeMessage(msg)
		m.Type = &Notification_Like{msg}
		return true, err
	case 2: // type.message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Message)
		err := b.DecodeMessage(msg)
		m.Type = &Notification_Message{msg}
		return true, err
	case 3: // type.tag
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Tag)
		err := b.DecodeMessage(msg)
		m.Type = &Notification_Tag{msg}
		return true, err
	case 4: // type.comment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Comment)
		err := b.DecodeMessage(msg)
		m.Type = &Notification_Comment{msg}
		return true, err
	case 5: // type.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &Notification_Custom{x}
		return true, err
	default:
		return false, nil
	}
}

func _Notification_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Notification)
	// type
	switch x := m.Type.(type) {
	case *Notification_Like:
		s := proto.Size(x.Like)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Notification_Message:
		s := proto.Size(x.Message)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Notification_Tag:
		s := proto.Size(x.Tag)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Notification_Comment:
		s := proto.Size(x.Comment)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Notification_Custom:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Custom)))
		n += len(x.Custom)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// *
// Picture represents a picture file, its identifiers, and its comments attached
type Picture struct {
	ContentFile    *File      `protobuf:"bytes,1,opt,name=contentFile" json:"contentFile,omitempty"`
	Identification int64      `protobuf:"varint,2,opt,name=identification" json:"identification,omitempty"`
	Comments       []*Comment `protobuf:"bytes,3,rep,name=comments" json:"comments,omitempty"`
}

func (m *Picture) Reset()                    { *m = Picture{} }
func (m *Picture) String() string            { return proto.CompactTextString(m) }
func (*Picture) ProtoMessage()               {}
func (*Picture) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Picture) GetContentFile() *File {
	if m != nil {
		return m.ContentFile
	}
	return nil
}

func (m *Picture) GetIdentification() int64 {
	if m != nil {
		return m.Identification
	}
	return 0
}

func (m *Picture) GetComments() []*Comment {
	if m != nil {
		return m.Comments
	}
	return nil
}

// *
// Video represents a video file, its identifiers, the thumbnail, and its comments attached
type Video struct {
	ContentFile   *File      `protobuf:"bytes,1,opt,name=contentFile" json:"contentFile,omitempty"`
	Identifcation int64      `protobuf:"varint,2,opt,name=identifcation" json:"identifcation,omitempty"`
	Thumbnail     *Picture   `protobuf:"bytes,3,opt,name=thumbnail" json:"thumbnail,omitempty"`
	Comments      []*Comment `protobuf:"bytes,4,rep,name=comments" json:"comments,omitempty"`
}

func (m *Video) Reset()                    { *m = Video{} }
func (m *Video) String() string            { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()               {}
func (*Video) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Video) GetContentFile() *File {
	if m != nil {
		return m.ContentFile
	}
	return nil
}

func (m *Video) GetIdentifcation() int64 {
	if m != nil {
		return m.Identifcation
	}
	return 0
}

func (m *Video) GetThumbnail() *Picture {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Video) GetComments() []*Comment {
	if m != nil {
		return m.Comments
	}
	return nil
}

// *
// Identifiers represents the common identifiers used by database and client
type Identifiers struct {
	// Types that are valid to be assigned to Identifiers:
	//	*Identifiers_User
	//	*Identifiers_Groupchat
	//	*Identifiers_IdentificationHash
	Identifiers isIdentifiers_Identifiers `protobuf_oneof:"identifiers"`
}

func (m *Identifiers) Reset()                    { *m = Identifiers{} }
func (m *Identifiers) String() string            { return proto.CompactTextString(m) }
func (*Identifiers) ProtoMessage()               {}
func (*Identifiers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isIdentifiers_Identifiers interface{ isIdentifiers_Identifiers() }

type Identifiers_User struct {
	User *User `protobuf:"bytes,1,opt,name=user,oneof"`
}
type Identifiers_Groupchat struct {
	Groupchat *Groupchat `protobuf:"bytes,2,opt,name=groupchat,oneof"`
}
type Identifiers_IdentificationHash struct {
	IdentificationHash int64 `protobuf:"varint,3,opt,name=identificationHash,oneof"`
}

func (*Identifiers_User) isIdentifiers_Identifiers()               {}
func (*Identifiers_Groupchat) isIdentifiers_Identifiers()          {}
func (*Identifiers_IdentificationHash) isIdentifiers_Identifiers() {}

func (m *Identifiers) GetIdentifiers() isIdentifiers_Identifiers {
	if m != nil {
		return m.Identifiers
	}
	return nil
}

func (m *Identifiers) GetUser() *User {
	if x, ok := m.GetIdentifiers().(*Identifiers_User); ok {
		return x.User
	}
	return nil
}

func (m *Identifiers) GetGroupchat() *Groupchat {
	if x, ok := m.GetIdentifiers().(*Identifiers_Groupchat); ok {
		return x.Groupchat
	}
	return nil
}

func (m *Identifiers) GetIdentificationHash() int64 {
	if x, ok := m.GetIdentifiers().(*Identifiers_IdentificationHash); ok {
		return x.IdentificationHash
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Identifiers) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Identifiers_OneofMarshaler, _Identifiers_OneofUnmarshaler, _Identifiers_OneofSizer, []interface{}{
		(*Identifiers_User)(nil),
		(*Identifiers_Groupchat)(nil),
		(*Identifiers_IdentificationHash)(nil),
	}
}

func _Identifiers_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Identifiers)
	// identifiers
	switch x := m.Identifiers.(type) {
	case *Identifiers_User:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.User); err != nil {
			return err
		}
	case *Identifiers_Groupchat:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Groupchat); err != nil {
			return err
		}
	case *Identifiers_IdentificationHash:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.IdentificationHash))
	case nil:
	default:
		return fmt.Errorf("Identifiers.Identifiers has unexpected type %T", x)
	}
	return nil
}

func _Identifiers_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Identifiers)
	switch tag {
	case 1: // identifiers.user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(User)
		err := b.DecodeMessage(msg)
		m.Identifiers = &Identifiers_User{msg}
		return true, err
	case 2: // identifiers.groupchat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Groupchat)
		err := b.DecodeMessage(msg)
		m.Identifiers = &Identifiers_Groupchat{msg}
		return true, err
	case 3: // identifiers.identificationHash
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Identifiers = &Identifiers_IdentificationHash{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Identifiers_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Identifiers)
	// identifiers
	switch x := m.Identifiers.(type) {
	case *Identifiers_User:
		s := proto.Size(x.User)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Identifiers_Groupchat:
		s := proto.Size(x.Groupchat)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Identifiers_IdentificationHash:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.IdentificationHash))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type User struct {
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *User) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type Groupchat struct {
	Users []*User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
}

func (m *Groupchat) Reset()                    { *m = Groupchat{} }
func (m *Groupchat) String() string            { return proto.CompactTextString(m) }
func (*Groupchat) ProtoMessage()               {}
func (*Groupchat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Groupchat) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type GeneralStatus struct {
	Status GeneralStatus_StatusCode `protobuf:"varint,1,opt,name=status,enum=protos.GeneralStatus_StatusCode" json:"status,omitempty"`
}

func (m *GeneralStatus) Reset()                    { *m = GeneralStatus{} }
func (m *GeneralStatus) String() string            { return proto.CompactTextString(m) }
func (*GeneralStatus) ProtoMessage()               {}
func (*GeneralStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *GeneralStatus) GetStatus() GeneralStatus_StatusCode {
	if m != nil {
		return m.Status
	}
	return GeneralStatus_OK
}

type Info struct {
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type File struct {
	FileBytes []byte `protobuf:"bytes,1,opt,name=fileBytes,proto3" json:"fileBytes,omitempty"`
	FileName  string `protobuf:"bytes,2,opt,name=fileName" json:"fileName,omitempty"`
	Checksum  int64  `protobuf:"varint,3,opt,name=checksum" json:"checksum,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *File) GetFileBytes() []byte {
	if m != nil {
		return m.FileBytes
	}
	return nil
}

func (m *File) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *File) GetChecksum() int64 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

type StreamedFileChunk struct {
	// Types that are valid to be assigned to ChunkContent:
	//	*StreamedFileChunk_FileBytes
	//	*StreamedFileChunk_FileName
	//	*StreamedFileChunk_Checksum
	ChunkContent isStreamedFileChunk_ChunkContent `protobuf_oneof:"ChunkContent"`
}

func (m *StreamedFileChunk) Reset()                    { *m = StreamedFileChunk{} }
func (m *StreamedFileChunk) String() string            { return proto.CompactTextString(m) }
func (*StreamedFileChunk) ProtoMessage()               {}
func (*StreamedFileChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type isStreamedFileChunk_ChunkContent interface{ isStreamedFileChunk_ChunkContent() }

type StreamedFileChunk_FileBytes struct {
	FileBytes []byte `protobuf:"bytes,1,opt,name=fileBytes,proto3,oneof"`
}
type StreamedFileChunk_FileName struct {
	FileName string `protobuf:"bytes,2,opt,name=fileName,oneof"`
}
type StreamedFileChunk_Checksum struct {
	Checksum int64 `protobuf:"varint,3,opt,name=checksum,oneof"`
}

func (*StreamedFileChunk_FileBytes) isStreamedFileChunk_ChunkContent() {}
func (*StreamedFileChunk_FileName) isStreamedFileChunk_ChunkContent()  {}
func (*StreamedFileChunk_Checksum) isStreamedFileChunk_ChunkContent()  {}

func (m *StreamedFileChunk) GetChunkContent() isStreamedFileChunk_ChunkContent {
	if m != nil {
		return m.ChunkContent
	}
	return nil
}

func (m *StreamedFileChunk) GetFileBytes() []byte {
	if x, ok := m.GetChunkContent().(*StreamedFileChunk_FileBytes); ok {
		return x.FileBytes
	}
	return nil
}

func (m *StreamedFileChunk) GetFileName() string {
	if x, ok := m.GetChunkContent().(*StreamedFileChunk_FileName); ok {
		return x.FileName
	}
	return ""
}

func (m *StreamedFileChunk) GetChecksum() int64 {
	if x, ok := m.GetChunkContent().(*StreamedFileChunk_Checksum); ok {
		return x.Checksum
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamedFileChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamedFileChunk_OneofMarshaler, _StreamedFileChunk_OneofUnmarshaler, _StreamedFileChunk_OneofSizer, []interface{}{
		(*StreamedFileChunk_FileBytes)(nil),
		(*StreamedFileChunk_FileName)(nil),
		(*StreamedFileChunk_Checksum)(nil),
	}
}

func _StreamedFileChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamedFileChunk)
	// ChunkContent
	switch x := m.ChunkContent.(type) {
	case *StreamedFileChunk_FileBytes:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.FileBytes)
	case *StreamedFileChunk_FileName:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.FileName)
	case *StreamedFileChunk_Checksum:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Checksum))
	case nil:
	default:
		return fmt.Errorf("StreamedFileChunk.ChunkContent has unexpected type %T", x)
	}
	return nil
}

func _StreamedFileChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamedFileChunk)
	switch tag {
	case 1: // ChunkContent.fileBytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ChunkContent = &StreamedFileChunk_FileBytes{x}
		return true, err
	case 2: // ChunkContent.fileName
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ChunkContent = &StreamedFileChunk_FileName{x}
		return true, err
	case 3: // ChunkContent.checksum
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ChunkContent = &StreamedFileChunk_Checksum{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _StreamedFileChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamedFileChunk)
	// ChunkContent
	switch x := m.ChunkContent.(type) {
	case *StreamedFileChunk_FileBytes:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.FileBytes)))
		n += len(x.FileBytes)
	case *StreamedFileChunk_FileName:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.FileName)))
		n += len(x.FileName)
	case *StreamedFileChunk_Checksum:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Checksum))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Credentials)(nil), "protos.Credentials")
	proto.RegisterType((*RefreshToken)(nil), "protos.RefreshToken")
	proto.RegisterType((*SignedToken)(nil), "protos.SignedToken")
	proto.RegisterType((*Message)(nil), "protos.Message")
	proto.RegisterType((*MessageStatus)(nil), "protos.MessageStatus")
	proto.RegisterType((*Comment)(nil), "protos.Comment")
	proto.RegisterType((*FeedContent)(nil), "protos.FeedContent")
	proto.RegisterType((*Profile)(nil), "protos.Profile")
	proto.RegisterType((*GetNext)(nil), "protos.GetNext")
	proto.RegisterType((*Follow)(nil), "protos.Follow")
	proto.RegisterType((*Like)(nil), "protos.Like")
	proto.RegisterType((*Tag)(nil), "protos.Tag")
	proto.RegisterType((*Notification)(nil), "protos.Notification")
	proto.RegisterType((*Picture)(nil), "protos.Picture")
	proto.RegisterType((*Video)(nil), "protos.Video")
	proto.RegisterType((*Identifiers)(nil), "protos.Identifiers")
	proto.RegisterType((*User)(nil), "protos.User")
	proto.RegisterType((*Groupchat)(nil), "protos.Groupchat")
	proto.RegisterType((*GeneralStatus)(nil), "protos.GeneralStatus")
	proto.RegisterType((*Info)(nil), "protos.Info")
	proto.RegisterType((*File)(nil), "protos.File")
	proto.RegisterType((*StreamedFileChunk)(nil), "protos.StreamedFileChunk")
	proto.RegisterEnum("protos.MessageStatus_StatusCode", MessageStatus_StatusCode_name, MessageStatus_StatusCode_value)
	proto.RegisterEnum("protos.GeneralStatus_StatusCode", GeneralStatus_StatusCode_name, GeneralStatus_StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Essential service

type EssentialClient interface {
	FetchCertificate(ctx context.Context, in *Info, opts ...grpc.CallOption) (*File, error)
	TestCall(ctx context.Context, in *Info, opts ...grpc.CallOption) (*GeneralStatus, error)
}

type essentialClient struct {
	cc *grpc.ClientConn
}

func NewEssentialClient(cc *grpc.ClientConn) EssentialClient {
	return &essentialClient{cc}
}

func (c *essentialClient) FetchCertificate(ctx context.Context, in *Info, opts ...grpc.CallOption) (*File, error) {
	out := new(File)
	err := grpc.Invoke(ctx, "/protos.Essential/FetchCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *essentialClient) TestCall(ctx context.Context, in *Info, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Essential/TestCall", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Essential service

type EssentialServer interface {
	FetchCertificate(context.Context, *Info) (*File, error)
	TestCall(context.Context, *Info) (*GeneralStatus, error)
}

func RegisterEssentialServer(s *grpc.Server, srv EssentialServer) {
	s.RegisterService(&_Essential_serviceDesc, srv)
}

func _Essential_FetchCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Info)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EssentialServer).FetchCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Essential/FetchCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EssentialServer).FetchCertificate(ctx, req.(*Info))
	}
	return interceptor(ctx, in, info, handler)
}

func _Essential_TestCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Info)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EssentialServer).TestCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Essential/TestCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EssentialServer).TestCall(ctx, req.(*Info))
	}
	return interceptor(ctx, in, info, handler)
}

var _Essential_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Essential",
	HandlerType: (*EssentialServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchCertificate",
			Handler:    _Essential_FetchCertificate_Handler,
		},
		{
			MethodName: "TestCall",
			Handler:    _Essential_TestCall_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/services.proto",
}

// Client API for TokenSecurity service

type TokenSecurityClient interface {
	RequestRefreshToken(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*SignedToken, error)
	RequestAccessToken(ctx context.Context, in *SignedToken, opts ...grpc.CallOption) (*SignedToken, error)
}

type tokenSecurityClient struct {
	cc *grpc.ClientConn
}

func NewTokenSecurityClient(cc *grpc.ClientConn) TokenSecurityClient {
	return &tokenSecurityClient{cc}
}

func (c *tokenSecurityClient) RequestRefreshToken(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*SignedToken, error) {
	out := new(SignedToken)
	err := grpc.Invoke(ctx, "/protos.TokenSecurity/RequestRefreshToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenSecurityClient) RequestAccessToken(ctx context.Context, in *SignedToken, opts ...grpc.CallOption) (*SignedToken, error) {
	out := new(SignedToken)
	err := grpc.Invoke(ctx, "/protos.TokenSecurity/RequestAccessToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TokenSecurity service

type TokenSecurityServer interface {
	RequestRefreshToken(context.Context, *Credentials) (*SignedToken, error)
	RequestAccessToken(context.Context, *SignedToken) (*SignedToken, error)
}

func RegisterTokenSecurityServer(s *grpc.Server, srv TokenSecurityServer) {
	s.RegisterService(&_TokenSecurity_serviceDesc, srv)
}

func _TokenSecurity_RequestRefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenSecurityServer).RequestRefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TokenSecurity/RequestRefreshToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenSecurityServer).RequestRefreshToken(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenSecurity_RequestAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenSecurityServer).RequestAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TokenSecurity/RequestAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenSecurityServer).RequestAccessToken(ctx, req.(*SignedToken))
	}
	return interceptor(ctx, in, info, handler)
}

var _TokenSecurity_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TokenSecurity",
	HandlerType: (*TokenSecurityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestRefreshToken",
			Handler:    _TokenSecurity_RequestRefreshToken_Handler,
		},
		{
			MethodName: "RequestAccessToken",
			Handler:    _TokenSecurity_RequestAccessToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/services.proto",
}

// Client API for Messaging service

type MessagingClient interface {
	FetchMessages(ctx context.Context, in *Info, opts ...grpc.CallOption) (Messaging_FetchMessagesClient, error)
	SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*MessageStatus, error)
	GetMessageStatus(ctx context.Context, opts ...grpc.CallOption) (Messaging_GetMessageStatusClient, error)
}

type messagingClient struct {
	cc *grpc.ClientConn
}

func NewMessagingClient(cc *grpc.ClientConn) MessagingClient {
	return &messagingClient{cc}
}

func (c *messagingClient) FetchMessages(ctx context.Context, in *Info, opts ...grpc.CallOption) (Messaging_FetchMessagesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Messaging_serviceDesc.Streams[0], c.cc, "/protos.Messaging/FetchMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &messagingFetchMessagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Messaging_FetchMessagesClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type messagingFetchMessagesClient struct {
	grpc.ClientStream
}

func (x *messagingFetchMessagesClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *messagingClient) SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*MessageStatus, error) {
	out := new(MessageStatus)
	err := grpc.Invoke(ctx, "/protos.Messaging/SendMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagingClient) GetMessageStatus(ctx context.Context, opts ...grpc.CallOption) (Messaging_GetMessageStatusClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Messaging_serviceDesc.Streams[1], c.cc, "/protos.Messaging/GetMessageStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &messagingGetMessageStatusClient{stream}
	return x, nil
}

type Messaging_GetMessageStatusClient interface {
	Send(*Message) error
	Recv() (*MessageStatus, error)
	grpc.ClientStream
}

type messagingGetMessageStatusClient struct {
	grpc.ClientStream
}

func (x *messagingGetMessageStatusClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *messagingGetMessageStatusClient) Recv() (*MessageStatus, error) {
	m := new(MessageStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Messaging service

type MessagingServer interface {
	FetchMessages(*Info, Messaging_FetchMessagesServer) error
	SendMessage(context.Context, *Message) (*MessageStatus, error)
	GetMessageStatus(Messaging_GetMessageStatusServer) error
}

func RegisterMessagingServer(s *grpc.Server, srv MessagingServer) {
	s.RegisterService(&_Messaging_serviceDesc, srv)
}

func _Messaging_FetchMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Info)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MessagingServer).FetchMessages(m, &messagingFetchMessagesServer{stream})
}

type Messaging_FetchMessagesServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type messagingFetchMessagesServer struct {
	grpc.ServerStream
}

func (x *messagingFetchMessagesServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Messaging_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagingServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Messaging/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagingServer).SendMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Messaging_GetMessageStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MessagingServer).GetMessageStatus(&messagingGetMessageStatusServer{stream})
}

type Messaging_GetMessageStatusServer interface {
	Send(*MessageStatus) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type messagingGetMessageStatusServer struct {
	grpc.ServerStream
}

func (x *messagingGetMessageStatusServer) Send(m *MessageStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *messagingGetMessageStatusServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Messaging_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Messaging",
	HandlerType: (*MessagingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _Messaging_SendMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchMessages",
			Handler:       _Messaging_FetchMessages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetMessageStatus",
			Handler:       _Messaging_GetMessageStatus_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protos/services.proto",
}

// Client API for Commenting service

type CommentingClient interface {
	PostComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error)
	DeleteComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error)
	EditComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error)
}

type commentingClient struct {
	cc *grpc.ClientConn
}

func NewCommentingClient(cc *grpc.ClientConn) CommentingClient {
	return &commentingClient{cc}
}

func (c *commentingClient) PostComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Commenting/PostComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentingClient) DeleteComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Commenting/DeleteComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentingClient) EditComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Commenting/EditComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Commenting service

type CommentingServer interface {
	PostComment(context.Context, *Comment) (*GeneralStatus, error)
	DeleteComment(context.Context, *Comment) (*GeneralStatus, error)
	EditComment(context.Context, *Comment) (*GeneralStatus, error)
}

func RegisterCommentingServer(s *grpc.Server, srv CommentingServer) {
	s.RegisterService(&_Commenting_serviceDesc, srv)
}

func _Commenting_PostComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentingServer).PostComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Commenting/PostComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentingServer).PostComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Commenting_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentingServer).DeleteComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Commenting/DeleteComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentingServer).DeleteComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Commenting_EditComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentingServer).EditComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Commenting/EditComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentingServer).EditComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

var _Commenting_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Commenting",
	HandlerType: (*CommentingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostComment",
			Handler:    _Commenting_PostComment_Handler,
		},
		{
			MethodName: "DeleteComment",
			Handler:    _Commenting_DeleteComment_Handler,
		},
		{
			MethodName: "EditComment",
			Handler:    _Commenting_EditComment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/services.proto",
}

// Client API for Browsing service

type BrowsingClient interface {
	GetProfile(ctx context.Context, in *User, opts ...grpc.CallOption) (*Profile, error)
	FollowUnFollow(ctx context.Context, in *User, opts ...grpc.CallOption) (*GeneralStatus, error)
	ChangePrivacy(ctx context.Context, in *User, opts ...grpc.CallOption) (*GeneralStatus, error)
	GetProfilePicture(ctx context.Context, in *User, opts ...grpc.CallOption) (*Picture, error)
}

type browsingClient struct {
	cc *grpc.ClientConn
}

func NewBrowsingClient(cc *grpc.ClientConn) BrowsingClient {
	return &browsingClient{cc}
}

func (c *browsingClient) GetProfile(ctx context.Context, in *User, opts ...grpc.CallOption) (*Profile, error) {
	out := new(Profile)
	err := grpc.Invoke(ctx, "/protos.Browsing/GetProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *browsingClient) FollowUnFollow(ctx context.Context, in *User, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Browsing/FollowUnFollow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *browsingClient) ChangePrivacy(ctx context.Context, in *User, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Browsing/ChangePrivacy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *browsingClient) GetProfilePicture(ctx context.Context, in *User, opts ...grpc.CallOption) (*Picture, error) {
	out := new(Picture)
	err := grpc.Invoke(ctx, "/protos.Browsing/GetProfilePicture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Browsing service

type BrowsingServer interface {
	GetProfile(context.Context, *User) (*Profile, error)
	FollowUnFollow(context.Context, *User) (*GeneralStatus, error)
	ChangePrivacy(context.Context, *User) (*GeneralStatus, error)
	GetProfilePicture(context.Context, *User) (*Picture, error)
}

func RegisterBrowsingServer(s *grpc.Server, srv BrowsingServer) {
	s.RegisterService(&_Browsing_serviceDesc, srv)
}

func _Browsing_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrowsingServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Browsing/GetProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrowsingServer).GetProfile(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Browsing_FollowUnFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrowsingServer).FollowUnFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Browsing/FollowUnFollow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrowsingServer).FollowUnFollow(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Browsing_ChangePrivacy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrowsingServer).ChangePrivacy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Browsing/ChangePrivacy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrowsingServer).ChangePrivacy(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _Browsing_GetProfilePicture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrowsingServer).GetProfilePicture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Browsing/GetProfilePicture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrowsingServer).GetProfilePicture(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

var _Browsing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Browsing",
	HandlerType: (*BrowsingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProfile",
			Handler:    _Browsing_GetProfile_Handler,
		},
		{
			MethodName: "FollowUnFollow",
			Handler:    _Browsing_FollowUnFollow_Handler,
		},
		{
			MethodName: "ChangePrivacy",
			Handler:    _Browsing_ChangePrivacy_Handler,
		},
		{
			MethodName: "GetProfilePicture",
			Handler:    _Browsing_GetProfilePicture_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/services.proto",
}

// Client API for Posting service

type PostingClient interface {
	PostComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error)
	PostFeedContent(ctx context.Context, in *FeedContent, opts ...grpc.CallOption) (*GeneralStatus, error)
}

type postingClient struct {
	cc *grpc.ClientConn
}

func NewPostingClient(cc *grpc.ClientConn) PostingClient {
	return &postingClient{cc}
}

func (c *postingClient) PostComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Posting/PostComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postingClient) PostFeedContent(ctx context.Context, in *FeedContent, opts ...grpc.CallOption) (*GeneralStatus, error) {
	out := new(GeneralStatus)
	err := grpc.Invoke(ctx, "/protos.Posting/PostFeedContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Posting service

type PostingServer interface {
	PostComment(context.Context, *Comment) (*GeneralStatus, error)
	PostFeedContent(context.Context, *FeedContent) (*GeneralStatus, error)
}

func RegisterPostingServer(s *grpc.Server, srv PostingServer) {
	s.RegisterService(&_Posting_serviceDesc, srv)
}

func _Posting_PostComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostingServer).PostComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Posting/PostComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostingServer).PostComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Posting_PostFeedContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedContent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostingServer).PostFeedContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Posting/PostFeedContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostingServer).PostFeedContent(ctx, req.(*FeedContent))
	}
	return interceptor(ctx, in, info, handler)
}

var _Posting_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Posting",
	HandlerType: (*PostingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostComment",
			Handler:    _Posting_PostComment_Handler,
		},
		{
			MethodName: "PostFeedContent",
			Handler:    _Posting_PostFeedContent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/services.proto",
}

// Client API for Updating service

type UpdatingClient interface {
	UpdateNotifications(ctx context.Context, opts ...grpc.CallOption) (Updating_UpdateNotificationsClient, error)
	UpdateComments(ctx context.Context, opts ...grpc.CallOption) (Updating_UpdateCommentsClient, error)
	UpdateMessages(ctx context.Context, opts ...grpc.CallOption) (Updating_UpdateMessagesClient, error)
	BackgroundNotifications(ctx context.Context, opts ...grpc.CallOption) (Updating_BackgroundNotificationsClient, error)
}

type updatingClient struct {
	cc *grpc.ClientConn
}

func NewUpdatingClient(cc *grpc.ClientConn) UpdatingClient {
	return &updatingClient{cc}
}

func (c *updatingClient) UpdateNotifications(ctx context.Context, opts ...grpc.CallOption) (Updating_UpdateNotificationsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Updating_serviceDesc.Streams[0], c.cc, "/protos.Updating/UpdateNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &updatingUpdateNotificationsClient{stream}
	return x, nil
}

type Updating_UpdateNotificationsClient interface {
	Send(*Notification) error
	Recv() (*Notification, error)
	grpc.ClientStream
}

type updatingUpdateNotificationsClient struct {
	grpc.ClientStream
}

func (x *updatingUpdateNotificationsClient) Send(m *Notification) error {
	return x.ClientStream.SendMsg(m)
}

func (x *updatingUpdateNotificationsClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *updatingClient) UpdateComments(ctx context.Context, opts ...grpc.CallOption) (Updating_UpdateCommentsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Updating_serviceDesc.Streams[1], c.cc, "/protos.Updating/UpdateComments", opts...)
	if err != nil {
		return nil, err
	}
	x := &updatingUpdateCommentsClient{stream}
	return x, nil
}

type Updating_UpdateCommentsClient interface {
	Send(*Notification) error
	Recv() (*Comment, error)
	grpc.ClientStream
}

type updatingUpdateCommentsClient struct {
	grpc.ClientStream
}

func (x *updatingUpdateCommentsClient) Send(m *Notification) error {
	return x.ClientStream.SendMsg(m)
}

func (x *updatingUpdateCommentsClient) Recv() (*Comment, error) {
	m := new(Comment)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *updatingClient) UpdateMessages(ctx context.Context, opts ...grpc.CallOption) (Updating_UpdateMessagesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Updating_serviceDesc.Streams[2], c.cc, "/protos.Updating/UpdateMessages", opts...)
	if err != nil {
		return nil, err
	}
	x := &updatingUpdateMessagesClient{stream}
	return x, nil
}

type Updating_UpdateMessagesClient interface {
	Send(*Notification) error
	Recv() (*Message, error)
	grpc.ClientStream
}

type updatingUpdateMessagesClient struct {
	grpc.ClientStream
}

func (x *updatingUpdateMessagesClient) Send(m *Notification) error {
	return x.ClientStream.SendMsg(m)
}

func (x *updatingUpdateMessagesClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *updatingClient) BackgroundNotifications(ctx context.Context, opts ...grpc.CallOption) (Updating_BackgroundNotificationsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Updating_serviceDesc.Streams[3], c.cc, "/protos.Updating/BackgroundNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &updatingBackgroundNotificationsClient{stream}
	return x, nil
}

type Updating_BackgroundNotificationsClient interface {
	Send(*Info) error
	Recv() (*Notification, error)
	grpc.ClientStream
}

type updatingBackgroundNotificationsClient struct {
	grpc.ClientStream
}

func (x *updatingBackgroundNotificationsClient) Send(m *Info) error {
	return x.ClientStream.SendMsg(m)
}

func (x *updatingBackgroundNotificationsClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Updating service

type UpdatingServer interface {
	UpdateNotifications(Updating_UpdateNotificationsServer) error
	UpdateComments(Updating_UpdateCommentsServer) error
	UpdateMessages(Updating_UpdateMessagesServer) error
	BackgroundNotifications(Updating_BackgroundNotificationsServer) error
}

func RegisterUpdatingServer(s *grpc.Server, srv UpdatingServer) {
	s.RegisterService(&_Updating_serviceDesc, srv)
}

func _Updating_UpdateNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UpdatingServer).UpdateNotifications(&updatingUpdateNotificationsServer{stream})
}

type Updating_UpdateNotificationsServer interface {
	Send(*Notification) error
	Recv() (*Notification, error)
	grpc.ServerStream
}

type updatingUpdateNotificationsServer struct {
	grpc.ServerStream
}

func (x *updatingUpdateNotificationsServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

func (x *updatingUpdateNotificationsServer) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Updating_UpdateComments_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UpdatingServer).UpdateComments(&updatingUpdateCommentsServer{stream})
}

type Updating_UpdateCommentsServer interface {
	Send(*Comment) error
	Recv() (*Notification, error)
	grpc.ServerStream
}

type updatingUpdateCommentsServer struct {
	grpc.ServerStream
}

func (x *updatingUpdateCommentsServer) Send(m *Comment) error {
	return x.ServerStream.SendMsg(m)
}

func (x *updatingUpdateCommentsServer) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Updating_UpdateMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UpdatingServer).UpdateMessages(&updatingUpdateMessagesServer{stream})
}

type Updating_UpdateMessagesServer interface {
	Send(*Message) error
	Recv() (*Notification, error)
	grpc.ServerStream
}

type updatingUpdateMessagesServer struct {
	grpc.ServerStream
}

func (x *updatingUpdateMessagesServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func (x *updatingUpdateMessagesServer) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Updating_BackgroundNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UpdatingServer).BackgroundNotifications(&updatingBackgroundNotificationsServer{stream})
}

type Updating_BackgroundNotificationsServer interface {
	Send(*Notification) error
	Recv() (*Info, error)
	grpc.ServerStream
}

type updatingBackgroundNotificationsServer struct {
	grpc.ServerStream
}

func (x *updatingBackgroundNotificationsServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

func (x *updatingBackgroundNotificationsServer) Recv() (*Info, error) {
	m := new(Info)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Updating_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Updating",
	HandlerType: (*UpdatingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpdateNotifications",
			Handler:       _Updating_UpdateNotifications_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateComments",
			Handler:       _Updating_UpdateComments_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateMessages",
			Handler:       _Updating_UpdateMessages_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "BackgroundNotifications",
			Handler:       _Updating_BackgroundNotifications_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protos/services.proto",
}

func init() { proto.RegisterFile("protos/services.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1446 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x6f, 0xdb, 0xc6,
	0x12, 0x27, 0x25, 0x59, 0x7f, 0x86, 0x96, 0x23, 0xaf, 0x63, 0x3c, 0xc1, 0x30, 0x5e, 0x8c, 0xc5,
	0x7b, 0x0f, 0x46, 0x02, 0x3b, 0x8e, 0x5e, 0x51, 0x27, 0x29, 0x8a, 0x56, 0x92, 0x69, 0x4b, 0x88,
	0xcc, 0x18, 0x94, 0x9c, 0x5e, 0x0a, 0x14, 0x0c, 0xb5, 0x96, 0x08, 0x4b, 0xa4, 0xca, 0x5d, 0x39,
	0xd1, 0xa9, 0x87, 0x9e, 0x7a, 0x29, 0x7a, 0x28, 0xd2, 0x4f, 0x90, 0x0f, 0x91, 0x7e, 0x89, 0x9e,
	0x7a, 0x2c, 0xd0, 0x8f, 0x52, 0xec, 0x72, 0x49, 0x91, 0xb4, 0x14, 0xdb, 0x28, 0x7a, 0xe3, 0xce,
	0xfc, 0x66, 0xe7, 0x37, 0xb3, 0xb3, 0x3b, 0x43, 0xd8, 0x9c, 0xf8, 0x1e, 0xf3, 0xe8, 0x63, 0x4a,
	0xfc, 0x2b, 0xc7, 0x26, 0x74, 0x5f, 0xac, 0x51, 0x3e, 0x10, 0x63, 0x1d, 0xb4, 0xa6, 0x4f, 0xfa,
	0xc4, 0x65, 0x8e, 0x35, 0xa2, 0x68, 0x0b, 0x8a, 0x53, 0x4a, 0x7c, 0xd7, 0x1a, 0x93, 0xaa, 0xba,
	0xa3, 0xee, 0x96, 0xcc, 0x68, 0xcd, 0x75, 0x13, 0x8b, 0xd2, 0x37, 0x9e, 0xdf, 0xaf, 0x66, 0x02,
	0x5d, 0xb8, 0xc6, 0x6b, 0xb0, 0x6a, 0x92, 0x0b, 0x9f, 0xd0, 0x61, 0xcf, 0xbb, 0x24, 0x2e, 0xfe,
	0x25, 0x03, 0x5a, 0xd7, 0x19, 0xb8, 0xa4, 0x2f, 0xd6, 0xe8, 0x10, 0xf2, 0x43, 0x62, 0xf5, 0x89,
	0x5f, 0x55, 0x77, 0xb2, 0xbb, 0x5a, 0xed, 0x41, 0x40, 0x83, 0xee, 0xc7, 0x40, 0xfb, 0x2d, 0x81,
	0xd0, 0x5d, 0xe6, 0xcf, 0x4c, 0x09, 0x47, 0xcf, 0xa1, 0x30, 0xb1, 0x66, 0x23, 0xcf, 0xe2, 0x3e,
	0xb9, 0xe5, 0xce, 0x22, 0xcb, 0xb3, 0x00, 0x12, 0x98, 0x86, 0x06, 0x68, 0x1b, 0x4a, 0xd4, 0x19,
	0xb8, 0x16, 0x9b, 0xfa, 0xa4, 0x9a, 0x15, 0x8c, 0xe7, 0x82, 0xad, 0x67, 0xa0, 0xc5, 0x1c, 0xa2,
	0x0a, 0x64, 0x2f, 0xc9, 0x4c, 0x06, 0xcd, 0x3f, 0xd1, 0x7d, 0x58, 0xb9, 0xb2, 0x46, 0x53, 0x22,
	0x83, 0x0d, 0x16, 0xcf, 0x33, 0x4f, 0xd5, 0xad, 0xe7, 0xb0, 0x1a, 0xf7, 0x78, 0x17, 0x5b, 0xfc,
	0x87, 0x0a, 0x85, 0x53, 0x42, 0xa9, 0x35, 0x20, 0x08, 0x41, 0x8e, 0x91, 0xb7, 0x4c, 0x1a, 0x8a,
	0x6f, 0xf4, 0x30, 0x76, 0x02, 0xdc, 0x58, 0xab, 0xad, 0x86, 0x11, 0x9f, 0x53, 0xe2, 0xb7, 0x94,
	0xd8, 0x89, 0x3c, 0x81, 0xd2, 0xc0, 0xf7, 0xa6, 0x13, 0x7b, 0x68, 0x31, 0x11, 0xa0, 0x56, 0x5b,
	0x0f, 0xc1, 0x27, 0xa1, 0xa2, 0xa5, 0x98, 0x73, 0x14, 0xda, 0x83, 0x3c, 0x65, 0x16, 0x9b, 0xd2,
	0x6a, 0x4e, 0xe0, 0x37, 0x43, 0xbc, 0xe4, 0xd4, 0x15, 0x4a, 0x53, 0x82, 0xd0, 0xff, 0x60, 0xcd,
	0x11, 0xc5, 0x71, 0xe1, 0xd8, 0x16, 0x73, 0x3c, 0xb7, 0x9a, 0xdf, 0x51, 0x77, 0xb3, 0x66, 0x4a,
	0xda, 0x28, 0x42, 0xde, 0xf6, 0xa6, 0x3e, 0x25, 0xb8, 0x03, 0xe5, 0xc4, 0x56, 0xf8, 0x33, 0x80,
	0xe0, 0xab, 0xe9, 0xf5, 0x09, 0x2a, 0x42, 0xae, 0xab, 0x1b, 0xbd, 0x8a, 0x82, 0xca, 0x50, 0x3a,
	0xd2, 0x3b, 0xed, 0x57, 0xba, 0xa9, 0x1f, 0x55, 0x54, 0xae, 0x30, 0xf5, 0xfa, 0x51, 0x25, 0x83,
	0x00, 0xf2, 0xc7, 0xf5, 0x76, 0x47, 0x3f, 0xaa, 0x64, 0xf1, 0x3b, 0x15, 0x0a, 0x4d, 0x6f, 0x3c,
	0x26, 0x2e, 0x5b, 0x98, 0xad, 0xeb, 0xfc, 0x32, 0x8b, 0xf8, 0xa1, 0x1d, 0xc8, 0xf1, 0xac, 0xc9,
	0x24, 0x25, 0x32, 0x6a, 0x0a, 0x0d, 0xda, 0x83, 0xc2, 0xc4, 0xb1, 0x45, 0xa9, 0x04, 0x99, 0xd9,
	0x08, 0x41, 0xc7, 0x84, 0xf4, 0x9b, 0x9e, 0xcb, 0x88, 0xcb, 0xcc, 0x10, 0x83, 0x47, 0xa0, 0xc5,
	0xe4, 0xe8, 0xd1, 0xdc, 0x5a, 0x15, 0xd6, 0xf7, 0x42, 0xeb, 0xb3, 0x40, 0xdc, 0x52, 0x22, 0x5b,
	0xf4, 0x5f, 0x58, 0xb9, 0x72, 0xfa, 0xc4, 0x93, 0xe7, 0x5b, 0x0e, 0xa1, 0xaf, 0xb8, 0xb0, 0xa5,
	0x98, 0x81, 0xb6, 0x51, 0x82, 0x82, 0x1d, 0x6c, 0x8f, 0xdf, 0xab, 0x50, 0x38, 0xf3, 0xbd, 0x0b,
	0x67, 0x44, 0xa2, 0x50, 0xd4, 0xa5, 0xa1, 0x1c, 0xc2, 0xda, 0x24, 0x00, 0x4b, 0xe7, 0xd2, 0x51,
	0x9a, 0x93, 0x99, 0x82, 0xf1, 0x1c, 0x48, 0x8f, 0xd5, 0xac, 0xb8, 0x6c, 0x8b, 0x73, 0x20, 0x31,
	0xbc, 0xec, 0x5f, 0x3b, 0x9e, 0x48, 0x57, 0xc9, 0xe4, 0x9f, 0xb8, 0x04, 0x85, 0x13, 0xc2, 0x0c,
	0xf2, 0x96, 0xe1, 0x87, 0x90, 0x3f, 0xf6, 0x46, 0x23, 0xef, 0xcd, 0xcd, 0x84, 0xf1, 0x04, 0x72,
	0x1d, 0xe7, 0x92, 0xdc, 0x2d, 0x8b, 0x8f, 0x38, 0x59, 0x51, 0x19, 0xe9, 0xf0, 0x64, 0xc1, 0x70,
	0xb0, 0x44, 0x34, 0xd6, 0x60, 0x75, 0xe4, 0x5c, 0x46, 0x31, 0xe0, 0x9f, 0x54, 0xc8, 0xf6, 0xac,
	0xc1, 0x3f, 0xe7, 0xf1, 0xe6, 0x8a, 0x6b, 0x94, 0x41, 0xeb, 0x59, 0x83, 0x8e, 0x17, 0x94, 0x28,
	0xfe, 0x4d, 0x85, 0x55, 0xc3, 0x8b, 0xd5, 0x2c, 0x86, 0x1c, 0xe7, 0x9c, 0xce, 0x1b, 0xcf, 0x54,
	0x4b, 0x31, 0x85, 0x8e, 0x53, 0x1a, 0x07, 0xb7, 0x2d, 0x4d, 0x49, 0x5e, 0x42, 0x4e, 0x49, 0x22,
	0xd0, 0x03, 0xc8, 0x32, 0x6b, 0x20, 0x19, 0x69, 0x21, 0xb0, 0x67, 0x0d, 0x5a, 0x8a, 0xc9, 0x35,
	0xf1, 0x00, 0x73, 0x37, 0x06, 0x58, 0x85, 0xbc, 0x3d, 0xa5, 0xcc, 0x1b, 0x57, 0x57, 0x78, 0x01,
	0xb4, 0x14, 0x53, 0xae, 0x1b, 0x79, 0xc8, 0xb1, 0xd9, 0x84, 0xe0, 0x1f, 0x79, 0xd5, 0xca, 0xdc,
	0xed, 0x83, 0x26, 0xcb, 0xe6, 0xd8, 0x19, 0x5d, 0x8b, 0x89, 0xcb, 0xcc, 0x38, 0xe0, 0xd6, 0x17,
	0xfb, 0x11, 0x14, 0x25, 0x21, 0x2a, 0x6b, 0x36, 0xcd, 0xd9, 0x8c, 0x00, 0xf8, 0x83, 0x0a, 0x2b,
	0xe2, 0x92, 0xdd, 0x99, 0xce, 0x7f, 0xa0, 0x2c, 0x1d, 0x27, 0xd8, 0x24, 0x85, 0x68, 0x0f, 0x4a,
	0x6c, 0x38, 0x1d, 0xbf, 0x76, 0x2d, 0x67, 0x24, 0xd3, 0x7c, 0xed, 0xce, 0xcd, 0x11, 0x09, 0xee,
	0xb9, 0x9b, 0xb8, 0xbf, 0x57, 0x41, 0x6b, 0xcb, 0xd8, 0x89, 0x4f, 0x79, 0x75, 0x2c, 0xbb, 0x55,
	0xbc, 0x3a, 0xc4, 0x43, 0x90, 0xe8, 0x0f, 0x99, 0x5b, 0xf5, 0x87, 0x03, 0x40, 0xc9, 0x0c, 0xb7,
	0x2c, 0x3a, 0x14, 0xb1, 0x64, 0x5b, 0x8a, 0xb9, 0x40, 0xc7, 0xcb, 0xd8, 0x99, 0xf3, 0xc2, 0x18,
	0x72, 0x9c, 0xc3, 0xc7, 0x26, 0x09, 0xfc, 0x18, 0x4a, 0x91, 0x7b, 0x84, 0x61, 0x85, 0x2b, 0xa8,
	0x9c, 0x0c, 0x92, 0x37, 0x25, 0x50, 0xe1, 0xdf, 0x55, 0x28, 0x9f, 0x10, 0x97, 0xf8, 0xd6, 0x28,
	0xe8, 0x25, 0xe8, 0x69, 0xd4, 0xc7, 0xf8, 0xe6, 0x6b, 0xf3, 0xb1, 0x20, 0x01, 0xdb, 0x9f, 0x77,
	0x9e, 0xb0, 0xa5, 0xe1, 0x1f, 0xd4, 0x44, 0x43, 0xca, 0x43, 0xe6, 0xe5, 0x8b, 0x8a, 0x12, 0xeb,
	0x3a, 0x2a, 0xd2, 0xa0, 0x70, 0x6e, 0xbc, 0x30, 0x5e, 0x7e, 0x65, 0x54, 0x32, 0x68, 0x13, 0xd6,
	0xcf, 0x74, 0xf3, 0xb4, 0xdd, 0xed, 0xb6, 0x5f, 0x1a, 0xdf, 0x1c, 0xe9, 0x46, 0x9b, 0x77, 0x26,
	0xb4, 0x01, 0xf7, 0xce, 0x8d, 0xfa, 0x79, 0xaf, 0xa5, 0x1b, 0xbd, 0x76, 0xb3, 0xde, 0xd3, 0x8f,
	0x2a, 0x39, 0xb4, 0x0e, 0xe5, 0x73, 0xa3, 0x7d, 0x7a, 0xd6, 0xd1, 0x4f, 0x75, 0x83, 0x8b, 0x56,
	0xd0, 0x2a, 0x14, 0xdb, 0x46, 0x4f, 0x37, 0x8d, 0x7a, 0xa7, 0x92, 0xe7, 0x4d, 0xaf, 0x59, 0x37,
	0x9a, 0x7a, 0x87, 0x3b, 0x2a, 0xe0, 0x3c, 0xe4, 0xda, 0xee, 0x85, 0x87, 0xbf, 0x86, 0x9c, 0x28,
	0xb3, 0x6d, 0x28, 0xf1, 0xf7, 0xb8, 0x31, 0x63, 0x24, 0x08, 0x6c, 0xd5, 0x9c, 0x0b, 0x78, 0x4a,
	0xf9, 0xc2, 0x08, 0x47, 0x83, 0x92, 0x19, 0xad, 0xb9, 0xce, 0x1e, 0x12, 0xfb, 0x92, 0x4e, 0xc7,
	0xc1, 0x69, 0x99, 0xd1, 0x1a, 0x7f, 0x07, 0xeb, 0x5d, 0xe6, 0x13, 0x6b, 0x4c, 0xfa, 0xdc, 0x4b,
	0x73, 0x38, 0x75, 0x2f, 0xd1, 0xbf, 0xaf, 0xb9, 0xe2, 0x85, 0x30, 0x77, 0xb6, 0x9d, 0x76, 0xc6,
	0x27, 0x8f, 0xc8, 0xdd, 0x76, 0xda, 0x1d, 0xd7, 0x86, 0x12, 0xfe, 0xda, 0x0a, 0x27, 0xf2, 0xb5,
	0xad, 0x4d, 0xa0, 0xa4, 0x53, 0x1a, 0xcc, 0x98, 0xe8, 0x00, 0x2a, 0xc7, 0x84, 0xd9, 0xc3, 0x26,
	0xf1, 0x65, 0x25, 0x11, 0x14, 0x1d, 0x3a, 0xcf, 0xc6, 0x56, 0xe2, 0x1e, 0x62, 0x05, 0x3d, 0x81,
	0x62, 0x8f, 0x50, 0xd6, 0xb4, 0x46, 0xa3, 0x14, 0x72, 0x73, 0xe1, 0xa9, 0x63, 0xa5, 0xf6, 0xb3,
	0x0a, 0x65, 0x31, 0x1a, 0x76, 0x89, 0x3d, 0xf5, 0x1d, 0x36, 0x43, 0x75, 0xd8, 0x30, 0xc9, 0xb7,
	0x53, 0x42, 0x59, 0x7c, 0x50, 0x45, 0x51, 0x87, 0x8b, 0x4d, 0xc1, 0x5b, 0x1b, 0x0b, 0x66, 0x4c,
	0xac, 0xa0, 0x2f, 0x01, 0xc9, 0x2d, 0xea, 0xb6, 0x4d, 0x28, 0x4d, 0xed, 0x10, 0x03, 0x2f, 0xd9,
	0xa1, 0xf6, 0xab, 0x0a, 0xa5, 0xe0, 0x61, 0x76, 0xdc, 0x01, 0xaa, 0x41, 0x59, 0x64, 0x42, 0x3e,
	0xd5, 0x34, 0x15, 0x5c, 0xfa, 0x29, 0xc7, 0xca, 0x81, 0x8a, 0x0e, 0x41, 0xeb, 0x12, 0xb7, 0x1f,
	0x4e, 0x90, 0x69, 0xcc, 0xd6, 0xe2, 0x79, 0x4e, 0x90, 0xaf, 0x9c, 0x10, 0x96, 0x90, 0xde, 0xde,
	0x7a, 0x57, 0x3d, 0x50, 0x6b, 0x1f, 0x54, 0x00, 0xf9, 0x2e, 0x71, 0xf6, 0x87, 0xa0, 0x9d, 0x79,
	0x94, 0x85, 0xd3, 0x59, 0xfa, 0xe9, 0x5a, 0x7a, 0x36, 0xe8, 0x19, 0x94, 0x8f, 0xc8, 0x88, 0x30,
	0x72, 0x77, 0xd3, 0x43, 0xd0, 0xf4, 0xbe, 0x73, 0x77, 0x9f, 0xb5, 0x3f, 0x55, 0x28, 0x36, 0x7c,
	0xef, 0x0d, 0xe5, 0xcc, 0xf7, 0x00, 0x4e, 0x08, 0x0b, 0xe7, 0xa9, 0xc4, 0x83, 0x33, 0x4f, 0xba,
	0x54, 0x0b, 0xa7, 0x6b, 0xc1, 0x24, 0x73, 0xee, 0xca, 0x89, 0x26, 0x69, 0xb2, 0x94, 0xed, 0xa7,
	0x50, 0x6e, 0x0e, 0x2d, 0x77, 0x40, 0xce, 0x7c, 0xe7, 0xca, 0xb2, 0x67, 0xb7, 0xb5, 0xfb, 0x04,
	0xd6, 0xe7, 0xfc, 0xc2, 0x06, 0xba, 0x8c, 0xa6, 0x9c, 0x47, 0x95, 0xda, 0xf7, 0xbc, 0xdb, 0x7a,
	0xf4, 0xef, 0x9d, 0xcd, 0x17, 0x70, 0x8f, 0x1b, 0xc6, 0x47, 0xdb, 0x45, 0x33, 0xe0, 0xf2, 0x44,
	0xbf, 0xcb, 0x40, 0xf1, 0x7c, 0xd2, 0xb7, 0x04, 0x8d, 0x13, 0xd8, 0x10, 0xdf, 0x24, 0x3e, 0xd7,
	0x50, 0x74, 0x3f, 0x34, 0x8e, 0x8b, 0xb7, 0x16, 0x4a, 0x83, 0xd2, 0x43, 0x9f, 0xc3, 0x5a, 0xb0,
	0x91, 0x0c, 0x60, 0xd9, 0x1e, 0xe9, 0x40, 0xd3, 0xe6, 0xd1, 0x4d, 0xbb, 0xc1, 0x3c, 0xba, 0x71,
	0xc2, 0xbc, 0x09, 0xff, 0x6a, 0x58, 0xf6, 0x25, 0x6f, 0x92, 0x6e, 0x3f, 0x19, 0x4a, 0xf2, 0xc6,
	0x7e, 0x24, 0x84, 0xd7, 0xc1, 0x0f, 0xf7, 0xff, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x3a, 0x86,
	0xc6, 0xcb, 0x90, 0x0f, 0x00, 0x00,
}
