// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protos/services.proto

/*
Package protos is a generated protocol buffer package.

It is generated from these files:
	protos/services.proto

It has these top-level messages:
	LastUpdateTime
	UserMessage
	Comment
	Beat
	Chunk
	Status
	PictureLocation
*/
package protos

import (
	fmt "fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_Unknown StatusCode = 0
	StatusCode_Success StatusCode = 1
	StatusCode_Failed  StatusCode = 2
)

var StatusCode_name = map[int32]string{
	0: "Unknown",
	1: "Success",
	2: "Failed",
}
var StatusCode_value = map[string]int32{
	"Unknown": 0,
	"Success": 1,
	"Failed":  2,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}
func (StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type LastUpdateTime struct {
	Time string `protobuf:"bytes,1,opt,name=Time" json:"Time,omitempty"`
}

func (m *LastUpdateTime) Reset()                    { *m = LastUpdateTime{} }
func (m *LastUpdateTime) String() string            { return proto.CompactTextString(m) }
func (*LastUpdateTime) ProtoMessage()               {}
func (*LastUpdateTime) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *LastUpdateTime) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type UserMessage struct {
	Message     string `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
	Destination string `protobuf:"bytes,2,opt,name=Destination" json:"Destination,omitempty"`
}

func (m *UserMessage) Reset()                    { *m = UserMessage{} }
func (m *UserMessage) String() string            { return proto.CompactTextString(m) }
func (*UserMessage) ProtoMessage()               {}
func (*UserMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UserMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *UserMessage) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type Comment struct {
	// Types that are valid to be assigned to MessageData:
	//	*Comment_Comment
	//	*Comment_Purpose
	//	*Comment_Location
	MessageData isComment_MessageData `protobuf_oneof:"messageData"`
}

func (m *Comment) Reset()                    { *m = Comment{} }
func (m *Comment) String() string            { return proto.CompactTextString(m) }
func (*Comment) ProtoMessage()               {}
func (*Comment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isComment_MessageData interface{ isComment_MessageData() }

type Comment_Comment struct {
	Comment string `protobuf:"bytes,1,opt,name=Comment,oneof"`
}
type Comment_Purpose struct {
	Purpose string `protobuf:"bytes,2,opt,name=Purpose,oneof"`
}
type Comment_Location struct {
	Location string `protobuf:"bytes,3,opt,name=location,oneof"`
}

func (*Comment_Comment) isComment_MessageData()  {}
func (*Comment_Purpose) isComment_MessageData()  {}
func (*Comment_Location) isComment_MessageData() {}

func (m *Comment) GetMessageData() isComment_MessageData {
	if m != nil {
		return m.MessageData
	}
	return nil
}

func (m *Comment) GetComment() string {
	if x, ok := m.GetMessageData().(*Comment_Comment); ok {
		return x.Comment
	}
	return ""
}

func (m *Comment) GetPurpose() string {
	if x, ok := m.GetMessageData().(*Comment_Purpose); ok {
		return x.Purpose
	}
	return ""
}

func (m *Comment) GetLocation() string {
	if x, ok := m.GetMessageData().(*Comment_Location); ok {
		return x.Location
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Comment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Comment_OneofMarshaler, _Comment_OneofUnmarshaler, _Comment_OneofSizer, []interface{}{
		(*Comment_Comment)(nil),
		(*Comment_Purpose)(nil),
		(*Comment_Location)(nil),
	}
}

func _Comment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Comment)
	// messageData
	switch x := m.MessageData.(type) {
	case *Comment_Comment:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Comment)
	case *Comment_Purpose:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Purpose)
	case *Comment_Location:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Location)
	case nil:
	default:
		return fmt.Errorf("Comment.MessageData has unexpected type %T", x)
	}
	return nil
}

func _Comment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Comment)
	switch tag {
	case 1: // messageData.Comment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MessageData = &Comment_Comment{x}
		return true, err
	case 2: // messageData.Purpose
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MessageData = &Comment_Purpose{x}
		return true, err
	case 3: // messageData.location
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.MessageData = &Comment_Location{x}
		return true, err
	default:
		return false, nil
	}
}

func _Comment_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Comment)
	// messageData
	switch x := m.MessageData.(type) {
	case *Comment_Comment:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Comment)))
		n += len(x.Comment)
	case *Comment_Purpose:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Purpose)))
		n += len(x.Purpose)
	case *Comment_Location:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Location)))
		n += len(x.Location)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Beat struct {
	Beat []byte `protobuf:"bytes,1,opt,name=Beat,proto3" json:"Beat,omitempty"`
}

func (m *Beat) Reset()                    { *m = Beat{} }
func (m *Beat) String() string            { return proto.CompactTextString(m) }
func (*Beat) ProtoMessage()               {}
func (*Beat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Beat) GetBeat() []byte {
	if m != nil {
		return m.Beat
	}
	return nil
}

type Chunk struct {
	// Types that are valid to be assigned to ChunkContent:
	//	*Chunk_Content
	//	*Chunk_Location
	//	*Chunk_TextPost
	//	*Chunk_Checksum
	ChunkContent isChunk_ChunkContent `protobuf_oneof:"ChunkContent"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isChunk_ChunkContent interface{ isChunk_ChunkContent() }

type Chunk_Content struct {
	Content []byte `protobuf:"bytes,1,opt,name=Content,proto3,oneof"`
}
type Chunk_Location struct {
	Location string `protobuf:"bytes,2,opt,name=Location,oneof"`
}
type Chunk_TextPost struct {
	TextPost string `protobuf:"bytes,3,opt,name=TextPost,oneof"`
}
type Chunk_Checksum struct {
	Checksum int64 `protobuf:"varint,4,opt,name=Checksum,oneof"`
}

func (*Chunk_Content) isChunk_ChunkContent()  {}
func (*Chunk_Location) isChunk_ChunkContent() {}
func (*Chunk_TextPost) isChunk_ChunkContent() {}
func (*Chunk_Checksum) isChunk_ChunkContent() {}

func (m *Chunk) GetChunkContent() isChunk_ChunkContent {
	if m != nil {
		return m.ChunkContent
	}
	return nil
}

func (m *Chunk) GetContent() []byte {
	if x, ok := m.GetChunkContent().(*Chunk_Content); ok {
		return x.Content
	}
	return nil
}

func (m *Chunk) GetLocation() string {
	if x, ok := m.GetChunkContent().(*Chunk_Location); ok {
		return x.Location
	}
	return ""
}

func (m *Chunk) GetTextPost() string {
	if x, ok := m.GetChunkContent().(*Chunk_TextPost); ok {
		return x.TextPost
	}
	return ""
}

func (m *Chunk) GetChecksum() int64 {
	if x, ok := m.GetChunkContent().(*Chunk_Checksum); ok {
		return x.Checksum
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Chunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Chunk_OneofMarshaler, _Chunk_OneofUnmarshaler, _Chunk_OneofSizer, []interface{}{
		(*Chunk_Content)(nil),
		(*Chunk_Location)(nil),
		(*Chunk_TextPost)(nil),
		(*Chunk_Checksum)(nil),
	}
}

func _Chunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Chunk)
	// ChunkContent
	switch x := m.ChunkContent.(type) {
	case *Chunk_Content:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Content)
	case *Chunk_Location:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Location)
	case *Chunk_TextPost:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.TextPost)
	case *Chunk_Checksum:
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Checksum))
	case nil:
	default:
		return fmt.Errorf("Chunk.ChunkContent has unexpected type %T", x)
	}
	return nil
}

func _Chunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Chunk)
	switch tag {
	case 1: // ChunkContent.Content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ChunkContent = &Chunk_Content{x}
		return true, err
	case 2: // ChunkContent.Location
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ChunkContent = &Chunk_Location{x}
		return true, err
	case 3: // ChunkContent.TextPost
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ChunkContent = &Chunk_TextPost{x}
		return true, err
	case 4: // ChunkContent.Checksum
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ChunkContent = &Chunk_Checksum{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Chunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Chunk)
	// ChunkContent
	switch x := m.ChunkContent.(type) {
	case *Chunk_Content:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Content)))
		n += len(x.Content)
	case *Chunk_Location:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Location)))
		n += len(x.Location)
	case *Chunk_TextPost:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.TextPost)))
		n += len(x.TextPost)
	case *Chunk_Checksum:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Checksum))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Status struct {
	Message string     `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
	Code    StatusCode `protobuf:"varint,2,opt,name=Code,enum=protos.StatusCode" json:"Code,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Status) GetCode() StatusCode {
	if m != nil {
		return m.Code
	}
	return StatusCode_Unknown
}

type PictureLocation struct {
	Location string `protobuf:"bytes,1,opt,name=Location" json:"Location,omitempty"`
}

func (m *PictureLocation) Reset()                    { *m = PictureLocation{} }
func (m *PictureLocation) String() string            { return proto.CompactTextString(m) }
func (*PictureLocation) ProtoMessage()               {}
func (*PictureLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PictureLocation) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func init() {
	proto.RegisterType((*LastUpdateTime)(nil), "protos.LastUpdateTime")
	proto.RegisterType((*UserMessage)(nil), "protos.UserMessage")
	proto.RegisterType((*Comment)(nil), "protos.Comment")
	proto.RegisterType((*Beat)(nil), "protos.Beat")
	proto.RegisterType((*Chunk)(nil), "protos.Chunk")
	proto.RegisterType((*Status)(nil), "protos.Status")
	proto.RegisterType((*PictureLocation)(nil), "protos.PictureLocation")
	proto.RegisterEnum("protos.StatusCode", StatusCode_name, StatusCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Messaging service

type MessagingClient interface {
	UpdateInbox(ctx context.Context, in *LastUpdateTime, opts ...grpc.CallOption) (Messaging_UpdateInboxClient, error)
	SendMessage(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error)
	DeleteMessage(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error)
	EditMessage(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error)
	ChangeMessageStatus(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error)
}

type messagingClient struct {
	cc *grpc.ClientConn
}

func NewMessagingClient(cc *grpc.ClientConn) MessagingClient {
	return &messagingClient{cc}
}

func (c *messagingClient) UpdateInbox(ctx context.Context, in *LastUpdateTime, opts ...grpc.CallOption) (Messaging_UpdateInboxClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Messaging_serviceDesc.Streams[0], c.cc, "/protos.Messaging/UpdateInbox", opts...)
	if err != nil {
		return nil, err
	}
	x := &messagingUpdateInboxClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Messaging_UpdateInboxClient interface {
	Recv() (*UserMessage, error)
	grpc.ClientStream
}

type messagingUpdateInboxClient struct {
	grpc.ClientStream
}

func (x *messagingUpdateInboxClient) Recv() (*UserMessage, error) {
	m := new(UserMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *messagingClient) SendMessage(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Messaging/SendMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagingClient) DeleteMessage(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Messaging/DeleteMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagingClient) EditMessage(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Messaging/EditMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagingClient) ChangeMessageStatus(ctx context.Context, in *UserMessage, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Messaging/ChangeMessageStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Messaging service

type MessagingServer interface {
	UpdateInbox(*LastUpdateTime, Messaging_UpdateInboxServer) error
	SendMessage(context.Context, *UserMessage) (*Status, error)
	DeleteMessage(context.Context, *UserMessage) (*Status, error)
	EditMessage(context.Context, *UserMessage) (*Status, error)
	ChangeMessageStatus(context.Context, *UserMessage) (*Status, error)
}

func RegisterMessagingServer(s *grpc.Server, srv MessagingServer) {
	s.RegisterService(&_Messaging_serviceDesc, srv)
}

func _Messaging_UpdateInbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LastUpdateTime)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MessagingServer).UpdateInbox(m, &messagingUpdateInboxServer{stream})
}

type Messaging_UpdateInboxServer interface {
	Send(*UserMessage) error
	grpc.ServerStream
}

type messagingUpdateInboxServer struct {
	grpc.ServerStream
}

func (x *messagingUpdateInboxServer) Send(m *UserMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _Messaging_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagingServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Messaging/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagingServer).SendMessage(ctx, req.(*UserMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Messaging_DeleteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagingServer).DeleteMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Messaging/DeleteMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagingServer).DeleteMessage(ctx, req.(*UserMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Messaging_EditMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagingServer).EditMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Messaging/EditMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagingServer).EditMessage(ctx, req.(*UserMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Messaging_ChangeMessageStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagingServer).ChangeMessageStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Messaging/ChangeMessageStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagingServer).ChangeMessageStatus(ctx, req.(*UserMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Messaging_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Messaging",
	HandlerType: (*MessagingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _Messaging_SendMessage_Handler,
		},
		{
			MethodName: "DeleteMessage",
			Handler:    _Messaging_DeleteMessage_Handler,
		},
		{
			MethodName: "EditMessage",
			Handler:    _Messaging_EditMessage_Handler,
		},
		{
			MethodName: "ChangeMessageStatus",
			Handler:    _Messaging_ChangeMessageStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpdateInbox",
			Handler:       _Messaging_UpdateInbox_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/services.proto",
}

// Client API for Commenting service

type CommentingClient interface {
	PostComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Status, error)
	DeleteComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Status, error)
	EditComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Status, error)
}

type commentingClient struct {
	cc *grpc.ClientConn
}

func NewCommentingClient(cc *grpc.ClientConn) CommentingClient {
	return &commentingClient{cc}
}

func (c *commentingClient) PostComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Commenting/PostComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentingClient) DeleteComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Commenting/DeleteComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentingClient) EditComment(ctx context.Context, in *Comment, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Commenting/EditComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Commenting service

type CommentingServer interface {
	PostComment(context.Context, *Comment) (*Status, error)
	DeleteComment(context.Context, *Comment) (*Status, error)
	EditComment(context.Context, *Comment) (*Status, error)
}

func RegisterCommentingServer(s *grpc.Server, srv CommentingServer) {
	s.RegisterService(&_Commenting_serviceDesc, srv)
}

func _Commenting_PostComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentingServer).PostComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Commenting/PostComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentingServer).PostComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Commenting_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentingServer).DeleteComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Commenting/DeleteComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentingServer).DeleteComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _Commenting_EditComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentingServer).EditComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Commenting/EditComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentingServer).EditComment(ctx, req.(*Comment))
	}
	return interceptor(ctx, in, info, handler)
}

var _Commenting_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Commenting",
	HandlerType: (*CommentingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostComment",
			Handler:    _Commenting_PostComment_Handler,
		},
		{
			MethodName: "DeleteComment",
			Handler:    _Commenting_DeleteComment_Handler,
		},
		{
			MethodName: "EditComment",
			Handler:    _Commenting_EditComment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/services.proto",
}

// Client API for Heartbeating service

type HeartbeatingClient interface {
	TradeHeartbeat(ctx context.Context, in *Beat, opts ...grpc.CallOption) (*Status, error)
}

type heartbeatingClient struct {
	cc *grpc.ClientConn
}

func NewHeartbeatingClient(cc *grpc.ClientConn) HeartbeatingClient {
	return &heartbeatingClient{cc}
}

func (c *heartbeatingClient) TradeHeartbeat(ctx context.Context, in *Beat, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/protos.Heartbeating/TradeHeartbeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Heartbeating service

type HeartbeatingServer interface {
	TradeHeartbeat(context.Context, *Beat) (*Status, error)
}

func RegisterHeartbeatingServer(s *grpc.Server, srv HeartbeatingServer) {
	s.RegisterService(&_Heartbeating_serviceDesc, srv)
}

func _Heartbeating_TradeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Beat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HeartbeatingServer).TradeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Heartbeating/TradeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HeartbeatingServer).TradeHeartbeat(ctx, req.(*Beat))
	}
	return interceptor(ctx, in, info, handler)
}

var _Heartbeating_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Heartbeating",
	HandlerType: (*HeartbeatingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TradeHeartbeat",
			Handler:    _Heartbeating_TradeHeartbeat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/services.proto",
}

// Client API for PictureUploading service

type PictureUploadingClient interface {
	UploadPicture(ctx context.Context, opts ...grpc.CallOption) (PictureUploading_UploadPictureClient, error)
}

type pictureUploadingClient struct {
	cc *grpc.ClientConn
}

func NewPictureUploadingClient(cc *grpc.ClientConn) PictureUploadingClient {
	return &pictureUploadingClient{cc}
}

func (c *pictureUploadingClient) UploadPicture(ctx context.Context, opts ...grpc.CallOption) (PictureUploading_UploadPictureClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PictureUploading_serviceDesc.Streams[0], c.cc, "/protos.PictureUploading/UploadPicture", opts...)
	if err != nil {
		return nil, err
	}
	x := &pictureUploadingUploadPictureClient{stream}
	return x, nil
}

type PictureUploading_UploadPictureClient interface {
	Send(*Chunk) error
	CloseAndRecv() (*Status, error)
	grpc.ClientStream
}

type pictureUploadingUploadPictureClient struct {
	grpc.ClientStream
}

func (x *pictureUploadingUploadPictureClient) Send(m *Chunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pictureUploadingUploadPictureClient) CloseAndRecv() (*Status, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for PictureUploading service

type PictureUploadingServer interface {
	UploadPicture(PictureUploading_UploadPictureServer) error
}

func RegisterPictureUploadingServer(s *grpc.Server, srv PictureUploadingServer) {
	s.RegisterService(&_PictureUploading_serviceDesc, srv)
}

func _PictureUploading_UploadPicture_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PictureUploadingServer).UploadPicture(&pictureUploadingUploadPictureServer{stream})
}

type PictureUploading_UploadPictureServer interface {
	SendAndClose(*Status) error
	Recv() (*Chunk, error)
	grpc.ServerStream
}

type pictureUploadingUploadPictureServer struct {
	grpc.ServerStream
}

func (x *pictureUploadingUploadPictureServer) SendAndClose(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pictureUploadingUploadPictureServer) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _PictureUploading_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.PictureUploading",
	HandlerType: (*PictureUploadingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadPicture",
			Handler:       _PictureUploading_UploadPicture_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "protos/services.proto",
}

// Client API for PictureDownloading service

type PictureDownloadingClient interface {
	DownloadPicture(ctx context.Context, in *PictureLocation, opts ...grpc.CallOption) (PictureDownloading_DownloadPictureClient, error)
}

type pictureDownloadingClient struct {
	cc *grpc.ClientConn
}

func NewPictureDownloadingClient(cc *grpc.ClientConn) PictureDownloadingClient {
	return &pictureDownloadingClient{cc}
}

func (c *pictureDownloadingClient) DownloadPicture(ctx context.Context, in *PictureLocation, opts ...grpc.CallOption) (PictureDownloading_DownloadPictureClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PictureDownloading_serviceDesc.Streams[0], c.cc, "/protos.PictureDownloading/DownloadPicture", opts...)
	if err != nil {
		return nil, err
	}
	x := &pictureDownloadingDownloadPictureClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PictureDownloading_DownloadPictureClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type pictureDownloadingDownloadPictureClient struct {
	grpc.ClientStream
}

func (x *pictureDownloadingDownloadPictureClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for PictureDownloading service

type PictureDownloadingServer interface {
	DownloadPicture(*PictureLocation, PictureDownloading_DownloadPictureServer) error
}

func RegisterPictureDownloadingServer(s *grpc.Server, srv PictureDownloadingServer) {
	s.RegisterService(&_PictureDownloading_serviceDesc, srv)
}

func _PictureDownloading_DownloadPicture_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PictureLocation)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PictureDownloadingServer).DownloadPicture(m, &pictureDownloadingDownloadPictureServer{stream})
}

type PictureDownloading_DownloadPictureServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type pictureDownloadingDownloadPictureServer struct {
	grpc.ServerStream
}

func (x *pictureDownloadingDownloadPictureServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

var _PictureDownloading_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.PictureDownloading",
	HandlerType: (*PictureDownloadingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadPicture",
			Handler:       _PictureDownloading_DownloadPicture_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/services.proto",
}

func init() { proto.RegisterFile("protos/services.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 547 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdb, 0x6e, 0xd3, 0x40,
	0x10, 0x8d, 0xdb, 0x90, 0xd0, 0x71, 0x6e, 0xda, 0x0a, 0x88, 0x2c, 0x1e, 0x22, 0x0b, 0xa1, 0x08,
	0x89, 0x12, 0x99, 0x8a, 0x17, 0x10, 0x42, 0x89, 0x41, 0x2d, 0x2a, 0x52, 0xc8, 0xe5, 0x03, 0x36,
	0xf6, 0x28, 0xb1, 0x12, 0xef, 0x46, 0xde, 0x35, 0xed, 0x4f, 0xf0, 0x17, 0xbc, 0xf2, 0x8f, 0x68,
	0xbd, 0xbb, 0x6e, 0x52, 0x45, 0xa8, 0x79, 0xf2, 0xce, 0x39, 0x33, 0x73, 0xce, 0xac, 0xc7, 0x86,
	0x67, 0xdb, 0x8c, 0x4b, 0x2e, 0xde, 0x09, 0xcc, 0x7e, 0x25, 0x11, 0x8a, 0x8b, 0x22, 0x26, 0x35,
	0x0d, 0xfb, 0xaf, 0xa0, 0x75, 0x43, 0x85, 0x9c, 0x6f, 0x63, 0x2a, 0x71, 0x96, 0xa4, 0x48, 0x08,
	0x54, 0xd5, 0xb3, 0xeb, 0xf4, 0x9c, 0xfe, 0xd9, 0xa4, 0x38, 0xfb, 0xd7, 0xe0, 0xce, 0x05, 0x66,
	0x3f, 0x50, 0x08, 0xba, 0x44, 0xd2, 0x85, 0xba, 0x39, 0x9a, 0x2c, 0x1b, 0x92, 0x1e, 0xb8, 0x21,
	0x0a, 0x99, 0x30, 0x2a, 0x13, 0xce, 0xba, 0x27, 0x05, 0xbb, 0x0b, 0xf9, 0x0c, 0xea, 0x23, 0x9e,
	0xa6, 0xc8, 0x24, 0xf1, 0xca, 0xa3, 0x6e, 0x73, 0x55, 0x99, 0xec, 0x72, 0xe3, 0x3c, 0xdb, 0x72,
	0x81, 0xba, 0x89, 0xe2, 0x0c, 0x40, 0x5e, 0xc2, 0xd3, 0x0d, 0x8f, 0xb4, 0xc2, 0xa9, 0x21, 0x4b,
	0x64, 0xd8, 0x04, 0x37, 0xd5, 0x6e, 0x42, 0x2a, 0xa9, 0xef, 0x41, 0x75, 0x88, 0x54, 0xaa, 0xb1,
	0xd4, 0xb3, 0x50, 0x6a, 0x4c, 0x8a, 0xb3, 0xff, 0xdb, 0x81, 0x27, 0xa3, 0x55, 0xce, 0xd6, 0xda,
	0x0a, 0x93, 0xd6, 0x4a, 0x43, 0x5b, 0x29, 0x00, 0x25, 0x77, 0x63, 0xe5, 0xac, 0x97, 0x12, 0x51,
	0xec, 0x0c, 0xef, 0xe4, 0x98, 0x0b, 0x79, 0x6f, 0xc6, 0x22, 0x8a, 0x1d, 0xad, 0x30, 0x5a, 0x8b,
	0x3c, 0xed, 0x56, 0x7b, 0x4e, 0xff, 0x54, 0xb1, 0x16, 0x19, 0xb6, 0xa0, 0x51, 0xc8, 0x1b, 0x25,
	0xff, 0x3b, 0xd4, 0xa6, 0x92, 0xca, 0x5c, 0xfc, 0xe7, 0x86, 0x5f, 0x43, 0x75, 0xc4, 0x63, 0x7d,
	0x2b, 0xad, 0x80, 0xe8, 0xd7, 0x29, 0x2e, 0x74, 0x9d, 0x62, 0x26, 0x05, 0xef, 0xbf, 0x85, 0xf6,
	0x38, 0x89, 0x64, 0x9e, 0x61, 0x69, 0xd5, 0xdb, 0x19, 0x44, 0x77, 0x2d, 0xe3, 0x37, 0x01, 0xc0,
	0x7d, 0x0b, 0xe2, 0x42, 0x7d, 0xce, 0xd6, 0x8c, 0xdf, 0xb2, 0x4e, 0x45, 0x05, 0xd3, 0x3c, 0x8a,
	0x50, 0x88, 0x8e, 0x43, 0x00, 0x6a, 0xdf, 0x68, 0xb2, 0xc1, 0xb8, 0x73, 0x12, 0xfc, 0x3d, 0x81,
	0x33, 0x6d, 0x2b, 0x61, 0x4b, 0xf2, 0x19, 0x5c, 0xbd, 0x45, 0xd7, 0x6c, 0xc1, 0xef, 0xc8, 0x73,
	0xeb, 0x6c, 0x7f, 0xbd, 0xbc, 0x73, 0x8b, 0xef, 0x2c, 0x94, 0x5f, 0x19, 0x38, 0xe4, 0x12, 0xdc,
	0x29, 0xb2, 0xd8, 0xce, 0x79, 0x28, 0xcf, 0x6b, 0xed, 0x8f, 0xeb, 0x57, 0xc8, 0x07, 0x68, 0x86,
	0xb8, 0x41, 0x89, 0x47, 0xd6, 0x5d, 0x82, 0xfb, 0x35, 0x4e, 0xe4, 0x91, 0x55, 0x9f, 0xe0, 0x7c,
	0xb4, 0xa2, 0x6c, 0x69, 0xd5, 0xcc, 0xdb, 0x7a, 0x5c, 0x75, 0xf0, 0xc7, 0x01, 0x30, 0xfb, 0xad,
	0x2e, 0x6c, 0x00, 0xae, 0xda, 0x11, 0xbb, 0xf1, 0x6d, 0x9b, 0x6f, 0x80, 0x03, 0xf2, 0x81, 0x1d,
	0xf6, 0x88, 0x9a, 0x81, 0x1e, 0xf4, 0xf1, 0x15, 0xc1, 0x17, 0x68, 0x5c, 0x21, 0xcd, 0xe4, 0x02,
	0xa9, 0xf1, 0xd9, 0x9a, 0x65, 0x34, 0xc6, 0x12, 0x24, 0x0d, 0x5b, 0xa3, 0xbe, 0xa2, 0x03, 0x1d,
	0x42, 0xe8, 0x98, 0xdd, 0x9b, 0x6f, 0x37, 0x9c, 0xc6, 0xba, 0x4b, 0x53, 0x07, 0x86, 0x21, 0xcd,
	0xd2, 0x89, 0xfa, 0x04, 0x1e, 0x76, 0xe9, 0x3b, 0xc1, 0x4f, 0x20, 0x26, 0x37, 0xe4, 0xb7, 0xcc,
	0xf6, 0xf9, 0x08, 0x6d, 0x1b, 0xda, 0x4e, 0x2f, 0x6c, 0xe9, 0x83, 0x85, 0xf7, 0xf6, 0x25, 0x06,
	0xce, 0x42, 0xff, 0xf5, 0xde, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x08, 0x0e, 0xca, 0xe0, 0x15,
	0x05, 0x00, 0x00,
}
